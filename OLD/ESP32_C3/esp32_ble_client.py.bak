import serial
import serial.tools.list_ports
import threading
import time

class ESP32BluetoothSerial:
    def __init__(self):
        self.serial_conn = None
        self.connected = False
        self.receive_callback = None
        
    def list_ports(self):
        """Список доступных COM портов"""
        ports = serial.tools.list_ports.comports()
        print("Доступные COM порты:")
        for port in ports:
            print(f"  {port.device} - {port.description}")
        return ports
    
    def connect(self, port_name=None, baudrate=115200):
        """Подключение к COM порту"""
        try:
            if port_name:
                port = port_name
            else:
                # Автопоиск порта с ESP32
                ports = serial.tools.list_ports.comports()
                port = None
                for p in ports:
                    if 'bluetooth' in p.description.lower() or 'ESP' in p.description or 'VR_head' in p.description:
                        port = p.device
                        break
                
                if not port and ports:
                    port = ports[0].device
                    print(f"Автоматически выбран порт: {port}")
            
            if not port:
                print("COM порты не найдены")
                return False
            
            print(f"Подключение к {port}...")
            self.serial_conn = serial.Serial(
                port=port,
                baudrate=baudrate,
                timeout=1,
                write_timeout=1
            )
            
            time.sleep(2)  # Ожидание инициализации
            self.connected = True
            print("Подключение установлено!")
            return True
            
        except Exception as e:
            print(f"Ошибка подключения: {e}")
            return False
    
    def set_receive_callback(self, callback):
        """Установка функции обратного вызова для приема данных"""
        self.receive_callback = callback
    
    def start_receiving(self):
        """Запуск потока для приема данных"""
        if not self.connected:
            print("Не подключено к устройству")
            return
        
        def receive_thread():
            while self.connected:
                try:
                    if self.serial_conn.in_waiting > 0:
                        data = self.serial_conn.readline().decode('utf-8').strip()
                        if data:
                            print(f"Получено: {data}")
                            if self.receive_callback:
                                self.receive_callback(data)
                    time.sleep(0.1)
                except Exception as e:
                    if self.connected:
                        print(f"Ошибка приема: {e}")
                    break
        
        thread = threading.Thread(target=receive_thread)
        thread.daemon = True
        thread.start()
    
    def send_data(self, data):
        """Отправка данных"""
        if not self.connected:
            print("Не подключено к устройству")
            return False
        
        try:
            if not data.endswith('\n'):
                data += '\n'
            self.serial_conn.write(data.encode('utf-8'))
            print(f"Отправлено: {data.strip()}")
            return True
        except Exception as e:
            print(f"Ошибка отправки: {e}")
            return False
    
    def disconnect(self):
        """Отключение от устройства"""
        if self.serial_conn:
            self.connected = False
            self.serial_conn.close()
            print("Отключено от устройства")

def main():
    # Создание экземпляра Bluetooth соединения
    esp32 = ESP32BluetoothSerial()
    
    # Показать доступные порты
    esp32.list_ports()
    
    # Функция для обработки входящих сообщений
    def handle_received_data(data):
        print(f"[Callback] Получены данные: {data}")
    
    esp32.set_receive_callback(handle_received_data)
    
    # Подключение к устройству
    if esp32.connect():
        # Запуск приема данных в отдельном потоке
        esp32.start_receiving()
        
        try:
            print("\nУправление:")
            print("  - Введите сообщение для отправки")
            print("  - Введите 'quit' для выхода")
            print("  - Введите 'ports' для списка портов")
            print("  - Введите 'status' для проверки статуса\n")
            
            while True:
                user_input = input("> ").strip()
                
                if user_input.lower() == 'quit':
                    break
                elif user_input.lower() == 'ports':
                    esp32.list_ports()
                elif user_input.lower() == 'status':
                    print(f"Статус подключения: {'Подключено' if esp32.connected else 'Не подключено'}")
                elif user_input:
                    esp32.send_data(user_input)
                    
        except KeyboardInterrupt:
            print("\nПрервано пользователем")
        finally:
            esp32.disconnect()
    else:
        print("\nРучное подключение:")
        port_name = input("Введите имя COM порта (например, COM3): ").strip()
        if esp32.connect(port_name):
            esp32.start_receiving()
            
            # Простой цикл отправки
            try:
                while True:
                    user_input = input("> ").strip()
                    if user_input.lower() == 'quit':
                        break
                    esp32.send_data(user_input)
            except KeyboardInterrupt:
                pass
            finally:
                esp32.disconnect()

if __name__ == "__main__":
    main()